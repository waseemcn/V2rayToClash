<!DOCTYPE html>
<html>
<head>
    <meta name="referrer" content="never">
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VMlessèŠ‚ç‚¹è½¬æ¢å·¥å…·</title>
	<script type="text/javascript" src="./js/sharedFunctions.js"></script>
	<script type="text/javascript">
		/**
		* é¡µé¢åŠ è½½æ—¶æŠŠå‚¨å­˜çš„Valueæ”¾å…¥æ–‡æœ¬ä¸­
		**/
		document.addEventListener("DOMContentLoaded", function() {
			// ä»æœ¬åœ°å­˜å‚¨è·å–å€¼
			const nodesValue = localStorage.getItem("nodes");
			const ipsValue = localStorage.getItem("tonodes");

			// è®¾ç½®å€¼åˆ° <textarea>
			const nodes = document.getElementById("nodes");
			nodes.value = nodesValue;
			const ips = document.getElementById("tonodes");
			ips.value = ipsValue;
		});
	</script>
</head>
<body>
	<label>VMess|ssåè®®/èŠ‚ç‚¹ï¼š</label>
	<textarea style="width: 100%; height: 200px;" id="nodes"></textarea>

	<br /><br /><br />

	<label>V2&nbsp;To&nbsp;Clashï¼ˆè‡ªåŠ¨å¤åˆ¶åˆ°äº†å‰ªè´´æ¿ï¼‰ï¼š</label>
	<textarea style="width: 100%; height: 300px;" id="tonodes"></textarea>

	<button style="width: 100%; height: 100px;" onclick="sub(event)">æäº¤</button>

	<script type="text/javascript" src="./js/axios.min.js"></script>
	<script type="text/javascript" src="./js/js-yaml.min.js"></script>
	<script type="text/javascript">
		var timer;

		function sub(event) {
			try {
				const nodesDom = document.getElementById("nodes"),
					tonodesDom = document.getElementById("tonodes");
				// console.log(nodesDom, ipsDom);
				const nodes = nodesDom.value, tonodes = tonodesDom.value;

				/**
				 * è§£å¯†Base64
				 * **/
				// èŠ‚ç‚¹å…¨éƒ¨åå­— nodeNames
				let nodeNames = [];
				const parseVmessLinks = (links) => {
				  const linkArr = links.split('\n');
				  const result = [];

				  for (const [index, link] of linkArr.entries()) {
				    if (link.trim() === '') continue;
				    let type = "vmess://";
				    const [t, an] = link.split("://");
				    if(t === "vmess") {
					    type = t + '://';

					    // const decodedLink = atob(an);
					    const decodedLink = new TextDecoder("utf-8").decode(Uint8Array.from(atob(an), c => c.charCodeAt(0)));
					    // const base64Encoded = btoa(decodedLink);
					    // console.log(base64Encoded)
					    const config = JSON.parse(decodedLink);
					    config.ps += "_" + index;
					    nodeNames.push(config.ps);
					    config.myType = type;
					    console.log(config);
						const toClash = nodeV2ToClash(config);
					    result.push(toClash);

				    }else if(t === "ss") {
						// å¯¹é“¾æ¥éƒ¨åˆ†è¿›è¡Œ URL è§£ç 
						const decodedLink = decodeURIComponent(an);

						// åˆ†å‰²è§£ç åçš„å­—ç¬¦ä¸²
						const parts = decodedLink.split("@");

						// è·å–æœåŠ¡å™¨ä¿¡æ¯éƒ¨åˆ†
						const serverInfo = parts[1];

						// åˆ†å‰²æœåŠ¡å™¨ä¿¡æ¯éƒ¨åˆ†
						const serverParts = serverInfo.split(":");

						const decodedBase64 = new TextDecoder("utf-8").decode(Uint8Array.from(atob(parts[0]), c => c.charCodeAt(0)));
						const decodedPass = decodedBase64.split(":");
						// è·å–å¯†ç å’Œåœ°å€ä¿¡æ¯
						const cipher = decodedPass[0];
						const password = decodedPass[1];
						const server = serverParts[0];
						const port = parseInt(serverParts[1]);


						// æ„å»º JSON å¯¹è±¡
						const json = {
						    "name": decodeURIComponent(link.split("#")[1]) + "_" + index, // è§£ç å¹¶è·å–åç§°éƒ¨åˆ†
						    "type": t,
						    "server": server,
						    "port": port,
						    "password": password,
						    "cipher": cipher
						};

					    nodeNames.push(json.name);
					    result.push(json);

				    }
				  }

				  return result;
				};

				const parsedConfigs = parseVmessLinks(nodes);
				console.log(parsedConfigs, nodeNames);


				/**
				 * è·å–æ¨¡æ¿
				 * **/ 
				axios.get('./template/V2RaySE.yaml').then(response => {
					try {
					  // è§£æYAMLæ•°æ®
					  const data = jsyaml.load(response.data);

					  // å¤„ç†è§£æåçš„æ•°æ®
					  // console.log(data);
					  return data;
					} catch (error) {
					  console.error('è§£æYAMLå‡ºé”™:', error);
					}
				}).catch(error => {
					console.error('è¯·æ±‚å‡ºé”™:', error);
				}).then((data) => {
					data.proxies = parsedConfigs;
					proxy_groups = data['proxy-groups'];
					let arrpg = ['ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'â™»ï¸ è‡ªåŠ¨é€‰æ‹©', 'ğŸŒ å›½å¤–åª’ä½“', 'ğŸ“² ç”µæŠ¥ä¿¡æ¯', 'â“‚ï¸ å¾®è½¯æœåŠ¡', 'ğŸ è‹¹æœæœåŠ¡', 'ğŸŸ æ¼ç½‘ä¹‹é±¼'];
					for (var i = 0; i < proxy_groups.length; i++) {
						const pg_name = proxy_groups[i].name;
						if(arrpg.includes(pg_name)){
							if(proxy_groups[i].proxies)
								proxy_groups[i].proxies.push(...nodeNames);
							else
								proxy_groups[i].proxies = nodeNames
						}

					}

					console.log(data);
					return data;
				}).then((data)=> {
					const yamlData = jsyaml.dump(data);
					// console.log(yamlData);
					tonodesDom.value = yamlData;

					clearTimeout(timer);
					toCopeText(yamlData, (v)=>{
						if(!v) return
						event.target.innerText = "èŠ‚ç‚¹å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿";
						event.target.disabled = true;
						timer = setTimeout(()=>{
							event.target.innerText = "æäº¤";
							event.target.disabled = false;
						}, 2000);
					});
				});
				
				// axios.get('./template/SSRDog.yaml').then(response => {
				// 	try {
				// 	  // è§£æYAMLæ•°æ®
				// 	  const data = jsyaml.load(response.data);

				// 	  // å¤„ç†è§£æåçš„æ•°æ®
				// 	  // console.log(data);
				// 	  return data;
				// 	} catch (error) {
				// 	  console.error('è§£æYAMLå‡ºé”™:', error);
				// 	}
				// }).catch(error => {
				// 	console.error('è¯·æ±‚å‡ºé”™:', error);
				// }).then((data) => {
				// 	data.proxies = parsedConfigs;
				// 	proxy_groups = data['proxy-groups'];
				// 	for (var i = 0; i < proxy_groups.length; i++) {
				// 		const pg_name = proxy_groups[i].name;
				// 		if(proxy_groups[i].proxies)
				// 			proxy_groups[i].proxies.push(...nodeNames);
				// 		else
				// 			proxy_groups[i].proxies = nodeNames

				// 	}

				// 	console.log(data);
				// 	return data;
				// }).then((data)=> {
				// 	const yamlData = jsyaml.dump(data);
				// 	// console.log(yamlData);
				// 	tonodesDom.value = yamlData;

				// 	clearTimeout(timer);
				// 	toCopeText(yamlData, (v)=>{
				// 		if(!v) return
				// 		event.target.innerText = "èŠ‚ç‚¹å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿";
				// 		event.target.disabled = true;
				// 		timer = setTimeout(()=>{
				// 			event.target.innerText = "æäº¤";
				// 			event.target.disabled = false;
				// 		}, 2000);
				// 	});
				// });

				localStorage.setItem("nodes", nodes);
				localStorage.setItem("tonodes", tonodes);

			} catch (error) {
				// å¤„ç†é”™è¯¯
				if (error instanceof DOMException && error.name === 'InvalidCharacterError') {
					contentDom.textContent = "å‘ç”Ÿé”™è¯¯ï¼šè¾“å…¥çš„èŠ‚ç‚¹æ²¡æœ‰æ­£ç¡®è¿›è¡Œç¼–ç ";
				} else {
					// å…¶ä»–å¼‚å¸¸
				}
				console.error("å‘ç”Ÿé”™è¯¯ï¼š", error);
			}

		}


		// V2ToClashèŠ‚ç‚¹
		function nodeV2ToClash(originalData) {

			// console.log(originalData);
			
			const tls = originalData.tls;
			const sni = originalData.sni;
			// originalData.type || originalData.net
			let network = originalData.net;
		    var newData = {
		        // "name": decodeURIComponent(originalData.ps),
		        "type": "", // ç§»é™¤æœ«å°¾çš„ "://"
		        "name": originalData.ps,
		        "server": originalData.add,
		        "port": parseInt(originalData.port),
		        "uuid": originalData.id,
		        "alterId": parseInt(originalData.aid),
		        "cipher": originalData.scy,
		        // è·³è¿‡è¯ä¹¦ç›®å‰æ²¡æœ‰è·å–åˆ° æœ‰bugï¼Œå¼€å¯äº†tlså¿…é¡»ä½false
		        "skip-cert-verify": false,
		        "network": network
		    };
		    if (network === 'ws') {
				newData["ws-opts"] = {
					"path": originalData.path,
					"headers": {
						"Host": originalData.host
					}
				};
			} else if(network === 'http'){
				newData["http-opts"] = {
					"path": [originalData.path],
					"headers": {
						"Host": [originalData.host]
					}
				};
			}
		    if(tls !== "none"){
		    	newData["tls"] = true;
		    }
		    if(sni){
		    console.log(sni);
		    	newData["servername"] = sni;
		    }

		    if (originalData.myType) {
		    	newData.type = originalData.myType.substr(0, originalData.myType.length - 3);
		    }


		    return newData;
		}

	</script>
</body>
</html>
